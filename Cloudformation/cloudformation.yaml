Parameters: 
  ProjectName:
    Type: String
    Description: The name of the project as well as what paid and key resources will be tagged with
    MinLength: 0
    MaxLength: 255
    Default: Atheer
  ProjectTagKeyName:
    Type: String
    Description: The name of the key of the tag of resources
    MinLength: 1
    MaxLength: 127
    AllowedPattern: "[ A-Za-z-_./=+]+"
    Default: Project
  DBDatabaseName:
    Type: String
    Description: The name of the database hosting Atheer
    MinLength: "1"
    MaxLength: "63"
  DBRootUser:
    Type: String
    Description: The root user name of the DB
    MinLength: "4"
    MaxLength: "63"
  DBRootPassword:
    Type: String
    Description: The root password of the DB
    MinLength: "8"
    MaxLength: "63"
  DBInstanceType:
    Type: String
    Description: The type of the underlying EC2 instance e.g. db.t3.micro
    Default: "db.t3.micro"
  DBBaseStorage:
    Type: Number
    Description: The minimum GiBs for the entire DB instance
    Default: 12
  ServerInstanceType:
    Type: String
    Description: The type of the EC2 instance e.g. t3.nano
    Default: "t3.nano"
  ServerImage:
    Type: String
    Description: The AMI
  ServerInstanceStorageSize:
    Type: Number
    MinValue: 8
    Default: 10
    Description: The size in (GiB) of the instance root volume
  ServerKeyName:
    Type: String
    Description: A private key name to access the server via SSH. Don't include extension.
    MinLength: "1"
    Default: "testKey"
  PublicS3BucketName:
    Type: String
    Description: The name of the S3 bucket to deploy
    AllowedPattern: "[a-z-]*"
  WebsiteDomainName:
    Type: String
    Description: "The domain name excluding https:// and / at the end. That is, just the pure name."

# TODO find an efficient way to refactor the availability zone used
Resources:
  # VPC
  Network:
    Type: AWS::EC2::VPC
    Properties: 
      CidrBlock: 10.0.0.0/16
      EnableDnsHostnames: true
      EnableDnsSupport: true
      InstanceTenancy: default
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  NetworkInternetGateway:
    Type: AWS::EC2::InternetGateway
  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties: 
      InternetGatewayId: !Ref NetworkInternetGateway
      VpcId: !Ref Network
  
  # - Route tables
  PrivateRouteTable:
    Type: AWS::EC2::RouteTable
    Properties: 
      VpcId: !Ref Network
  PublicRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref Network
    
  # - Routes 
  RouteToInternet:
    DependsOn: InternetGatewayAttachment
    Type: AWS::EC2::Route
    Properties:
      RouteTableId: !Ref PublicRouteTable
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref NetworkInternetGateway
      
  # - Subnets
  PrivateSubnet:
    Type: AWS::EC2::Subnet
    Properties: 
      VpcId: !Ref Network
      CidrBlock: 10.0.0.0/24
      AvailabilityZone: !Select [ 0, !GetAZs ""]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  SecondPrivateSubnet:
    # \Because RDS Subnet group requires 2 zones
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref Network
      CidrBlock: 10.0.1.0/24
      AvailabilityZone: !Select [ 1, !GetAZs "" ]
      MapPublicIpOnLaunch: false
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  PublicSubnet:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref Network
      CidrBlock: 10.0.2.0/24
      AvailabilityZone: !Select [ 0, !GetAZs ""]
      MapPublicIpOnLaunch: true
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
      
  # - Subnets associations with Route tables
  PublicSubnetRouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties: 
      RouteTableId: !Ref PublicRouteTable
      SubnetId: !Ref PublicSubnet

#  Database
  DatabaseSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref Network
      GroupDescription: Only allow VPC in
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5432
          ToPort: 5432
          # from VPC only
          CidrIp: 10.0.0.0/16
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  DatabaseSubnetGroup:
    DependsOn: 
      - Network
    Type: AWS::RDS::DBSubnetGroup
    Properties:
      DBSubnetGroupDescription: The subnet for the database
      SubnetIds:
        - !Ref PrivateSubnet
        - !Ref SecondPrivateSubnet
  Database:
    Type: AWS::RDS::DBInstance
    Properties:
      AllocatedStorage: !Ref DBBaseStorage
      AllowMajorVersionUpgrade: false
      AutoMinorVersionUpgrade: false
      AvailabilityZone: !Select [ 0, !GetAZs ""]
      BackupRetentionPeriod: 7
      DBInstanceClass: !Ref DBInstanceType
      DeleteAutomatedBackups: false
      DeletionProtection: true
      Engine: postgres
      EngineVersion: "12.5"
      # TODO switch to gp3 when supported
      StorageType: gp2
      DBInstanceIdentifier: database
      DBName: !Ref DBDatabaseName
      MasterUsername: !Ref DBRootUser
      MasterUserPassword: !Ref DBRootPassword
      Port: "5432"
      PubliclyAccessible: false
      VPCSecurityGroups:
        - Fn::GetAtt: [ DatabaseSecurityGroup, GroupId ]
      DBSubnetGroupName: !Ref DatabaseSubnetGroup
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
      
  # S3
  # - Public bucket for static files
  BucketOAI:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: Allow Cloudfront to access S3 bucket
  Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain
    Properties:
      BucketName: !Ref PublicS3BucketName
      AccessControl: Private
      CorsConfiguration:
        CorsRules:
          - AllowedMethods:
              - GET
            AllowedOrigins:
              - "*"
            AllowedHeaders:
              - "*"
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  # So S3 Can be accessed from within the vpc directly than through internet
  S3VPCEndpoint:
    Type: 'AWS::EC2::VPCEndpoint'
    Properties:
      VpcEndpointType: Gateway
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal: '*'
            Action: "*"
            Resource:
              Fn::Join:
                - ""
                - - !GetAtt Bucket.Arn
                  - "/*"
      RouteTableIds:
        - !Ref PublicRouteTable
      ServiceName: !Sub "com.amazonaws.${AWS::Region}.s3"
      VpcId: !Ref Network
  BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref Bucket
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - s3:GetObject
            Effect: Allow
            Resource:
              Fn::Join:
                - ""
                - - !GetAtt Bucket.Arn
                  - "/*"
            Principal:
              CanonicalUser: !GetAtt BucketOAI.S3CanonicalUserId
  Cdn:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !GetAtt Bucket.RegionalDomainName
            Id: !Ref Bucket
            S3OriginConfig:
              OriginAccessIdentity: !Sub "origin-access-identity/cloudfront/${BucketOAI}"
        Enabled: true
        Comment: Cloudfront in front of S3
        DefaultRootObject: ""
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
          Compress: true
          TargetOriginId: !Ref Bucket
          ViewerProtocolPolicy: allow-all
          # Managed-CachingOptimized at https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html
          CachePolicyId: "658327ea-f89d-4fab-a63d-7e88639e58f6"
        PriceClass: PriceClass_All
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName

  # Server
  ServerRole:
    Type: AWS::IAM::Role
    Properties: 
      # This one makes sure this policy is for EC2 instances
      AssumeRolePolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - "sts:AssumeRole"
      Path: /
      # The actual policies
      Policies: 
        - PolicyName: ServerRolePolicies
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: 
                  - ssm:Describe*
                  - ssm:Get*
                  - ssm:List*
                Resource: "*"
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                Resource: !GetAtt NarrationQueue.Arn
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !GetAtt Bucket.Arn
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  ServerInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties: 
      Roles: 
        - !Ref ServerRole
  ServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: Server Security Group
      GroupDescription: Allow public traffic in
      VpcId: !Ref Network
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  Server:
    DependsOn: 
      - Database
    Type: AWS::EC2::Instance
    Properties: 
      BlockDeviceMappings:
        - DeviceName: "/dev/sda1"
          Ebs:
            VolumeSize: !Ref ServerInstanceStorageSize
            VolumeType: gp3
            DeleteOnTermination: true
      KeyName: !Ref ServerKeyName
      ImageId: !Ref ServerImage
      InstanceType: !Ref ServerInstanceType
      IamInstanceProfile: !Ref ServerInstanceProfile
      SubnetId: !Ref PublicSubnet
      SecurityGroupIds:
        - !Ref ServerSecurityGroup
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
      UserData:
        !Base64 |
        #!/bin/bash
        apt-get update -y
        apt-get upgrade -y
        apt install git -y
        apt install tmux -y
        apt install postgresql-client -y
        # Install dotnet - BEGIN
        # https://docs.microsoft.com/en-us/dotnet/core/install/linux-ubuntu#2004-
        wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb
        sudo apt-get update -y; \
          sudo apt-get install -y apt-transport-https && \
          sudo apt-get update && \
          sudo apt-get install -y dotnet-sdk-5.0
        sudo apt-get update -y; \
          sudo apt-get install -y apt-transport-https && \
          sudo apt-get update && \
          sudo apt-get install -y aspnetcore-runtime-5.0
        ## END
        cd /home/ubuntu/
        mkdir atheer
        cd atheer
        export DOTNET_CLI_HOME="/tmp"
        git clone https://github.com/Morr0/Atheer .
        cd Atheer
        # Create a detached tmux session and run the website in it
        tmux new-session -d -s server "dotnet run --environment Production"

  NarrationQueue:
    Type: AWS::SQS::Queue
    Properties:
      VisibilityTimeout: 301
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
  NarrationLambdaFunctionExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: "/"
      Policies:
        - PolicyName: NarrationLambdaFunctionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                Resource: !GetAtt Bucket.Arn
              - Effect: Allow
                Action:
                  - polly:SynthesizeSpeech
                Resource: "*"
              - Effect: Allow
                Action:
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueAttributes
                Resource: !GetAtt NarrationQueue.Arn
              - Effect: Allow
                Action:
                  - ec2:DescribeNetworkInterfaces
                  - ec2:CreateNetworkInterface
                  - ec2:DeleteNetworkInterface
                  - ec2:DescribeInstances
                  - ec2:AttachNetworkInterface
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"
  NarrationLambdaSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref Network
      GroupDescription: Only allow VPC in
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName 
  NarrationLambdaFunction:
    Type: AWS::Lambda::Function
    Properties: 
      Runtime: "nodejs12.x"
      Role: !GetAtt NarrationLambdaFunctionExecutionRole.Arn
      Handler: "index.handler"
      Code:
        ZipFile: |
          const awsSdk = require("aws-sdk");
          const https = require("https");

          const {
              S3BucketName,
              DomainNameToNotify
          } = process.env;

          exports.handler = async (event) => {
              const record = event.Records[0];
              const {createdYear, titleShrinked, content} = JSON.parse(record.body);

              const cleanedArticleContent = cleanAllHtml(content);
              console.log(`Cleaned Article Content:\n${cleanedArticleContent}\n`);

              console.log("Beginning audio narration");
              const audioStream = await narrate(cleanedArticleContent);
              console.log("Finished audio narration");

              const fileName = `${createdYear}-${titleShrinked}`;
              console.log("Saving to S3");
              const fileKey = await addToBucket(fileName, audioStream);
              console.log("Saved to S3");

              console.log("Notifying Webhook");
              await notifyWebhook(createdYear, titleShrinked, fileKey);
          };

          const cleanAllHtml = (htmlText) => {
              const pattern = /<.*?>/g;
              return htmlText.replace(pattern, "");
          };

          const narrate = async (content) => {
              const pollyClient = new awsSdk.Polly();

              const params = {
                  OutputFormat: "mp3",
                  Text: content,
                  VoiceId: "Matthew"
              };
              const response = await pollyClient.synthesizeSpeech(params).promise();
              return response.AudioStream;
          };

          const addToBucket = async (fileName, audioStream) => {
              const s3Client = new awsSdk.S3();

              const s3Key = `ArticleNarration/${fileName}.mp3`;
              const params = {
                  Bucket: S3BucketName,
                  Key: s3Key,
                  Body: audioStream,
                  ACL: "public-read"
              };
              await s3Client.putObject(params).promise();

              const url = `https://${S3BucketName}.s3.amazonaws.com/${s3Key}`;
              console.log(`S3 url: ${url}`);
              return s3Key;
          };

          const notifyWebhook = async (createdYear, titleShrinked, s3BucketKey) => {
              const body = {
                  "CreatedYear": createdYear,
                  "TitleShrinked": titleShrinked,
                  "S3BucketKey": s3BucketKey
              };
              const bodyString = JSON.stringify(body);

              try {
                  const options = {
                      hostname: DomainNameToNotify,
                      port: 443,
                      path: "/api/article/narration/complete",
                      method: "PATCH",
                      headers: {
                          "Content-Type": "application/json",
                          "Content-Length": bodyString.length
                      }
                  };
                  await sendRequest(options, bodyString);
                  console.log("Notified Webhook");
              } catch (e){
                  console.log(`Could not send webhook since it was not found`);
                  console.log(e);
              }
          }

          const sendRequest = (options, data) => {
              return new Promise((resolve, reject) => {
                   const req = https.request(options);

                   req.on("error", (e) => reject(e));

                   req.write(data);
                   req.end();
              });
          };
        
    
    
      Description: "The narration function that picks up from the queue"
      Timeout: 300
      MemorySize: 128
      VpcConfig:
        SecurityGroupIds:
          - !Ref NarrationLambdaSecurityGroup
        SubnetIds:
          - !Ref PublicSubnet
      Tags:
        - Key: !Ref ProjectTagKeyName
          Value: !Ref ProjectName
      Environment: 
        Variables:
          S3BucketName: !Ref Bucket
          DomainNameToNotify: !Ref WebsiteDomainName
  NarrationLambdaFunctionTrigger:
    Type: AWS::Lambda::EventSourceMapping
    Properties: 
      FunctionName: !GetAtt NarrationLambdaFunction.Arn
      EventSourceArn: !GetAtt NarrationQueue.Arn
      BatchSize: 1
      Enabled: true
      
      
  # Configuration (stored in parameter store)
  SQSTranscriptionQueueUrlConfig:
    Type: AWS::SSM::Parameter
    Properties: 
      Type: String
      Value: !Ref NarrationQueue
      Name: "/Atheer/SQS/TranscriptionQueueUrl"
  
  
Outputs: 
  CdnDomainName:
    Description: Domain name of the Cdn
    Value: !GetAtt Cdn.DomainName